var documenterSearchIndex = {"docs":
[{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = IsDef","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#Core","page":"Library","title":"Core","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"isdef\nOut","category":"page"},{"location":"library/#IsDef.isdef","page":"Library","title":"IsDef.isdef","text":"isdef(func, ArgType1, ArgType2, ...)::Bool\nisdef(f, args...) = isdef(f, typeof.(args)...)\n\nChecks whether the function is defined for the actual types or not. This works in compile time and hence can be used to optimize code.\n\nWhen called on values, the values will be cast to types via use of typeof for convenience.\n\n\n\n\n\n","category":"function"},{"location":"library/#IsDef.Out","page":"Library","title":"IsDef.Out","text":"Out(func, ArgType1, ArgType2, ...)::ReturnType\nOut(func, bytevalue1, ArgType2, ...)::ReturnType\n\nReturns outputtype of function application. Returns IsDef.NotApplicable if compiler notices that no Method can be found.\n\n\n\n\n\n","category":"function"},{"location":"library/#ValType","page":"Library","title":"ValType","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ValTypes\nValType\nValTypeof","category":"page"},{"location":"library/#IsDef.Utils.ValTypes.ValType","page":"Library","title":"IsDef.Utils.ValTypes.ValType","text":"    ValType(value) -> ValType{typeof(value), value}\n\nAlternative to Base.Val which makes the type of the value accessible for dispatch.\n\nIn order to retrieve the value you can simple use Base.get on either the instance or the type.\n\njulia> ValTypeof(1)\nValType{Int, 1}\n\njulia> get(ValTypeof(1))\n1\n\njulia> ValTypeof(1) <: ValType{Int}\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/#IsDef.Utils.ValTypes.ValTypeof","page":"Library","title":"IsDef.Utils.ValTypes.ValTypeof","text":"important: the ValType construct DOES NOT construct a value, but a type.\n\n\n\n\n\n","category":"function"},{"location":"library/#Special-Applicability-Types","page":"Library","title":"Special Applicability Types","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"NotApplicable\nUnsureWhetherApplicable\nApplicabilityProblem\nisapplicable","category":"page"},{"location":"library/#Other-helpers","page":"Library","title":"Other helpers","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"apply\nCore_return_type\nrevise!\nsuppress_warnings","category":"page"},{"location":"library/#IsDef.apply","page":"Library","title":"IsDef.apply","text":"just applies a given function to arguments and keyword arguments\n\nThis little helper is crucial if you want to typeinfer when only knowing the function type instead of the function instance.\n\n\n\n\n\n","category":"function"},{"location":"library/#IsDef.revise!","page":"Library","title":"IsDef.revise!","text":"because revise does not work well for generated functions, dynamo and eval, we provide a manual way to revise the implementation\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"CurrentModule = IsDef\nDocTestSetup = quote\n    using IsDef\nend","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This package provides primitives for dispatching on whether certain methods are implemented or not.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For installation or usage, open julia repl and run","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using IsDef","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"which gives you access to following functions","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"isdef(f, arg1, arg2)::Bool / isdef(f, Arg1Type, Arg2Type)::Bool checks whether a function is defined for the given types.\nIf at least one of the arguments is not a type,   all arguments are automatically converted to types for you.\nOut(f, arg1, arg2)::ReturnType / Out(f, Arg1Type, Arg2Type)::ReturnType returns the returntype of the given functioncall.\nNote, that Out may return an abstract type that is wider than necessary, like e.g. Any.   If a functioncall is not defined, or predictably throws an error, IsDef.NotApplicable is returned.   Out is internally used by isdef.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Internally of Out(f, Arg1Type, Arg2Type) a one-argument-version of Out is used which expects a single Tuple type, specifying the entire call signature. This is the heart of the IsDef package. For the example it would be","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Out(Tuple{typeof(f), Arg1Type, Arg2Type})","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If you want to specify inference of your method (output of Out), or whether it is defined (output of isdef), you need to overload this very one-argument method of Out. For the example it could be","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Out(::Type{<:Tuple{typeof(f), Arg1Type, Arg2Type, Vararg}}) = ReturnType","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Enjoy maintainable type inference.","category":"page"},{"location":"manual/#Example-application:-Use-isdef-for-Traits","page":"Manual","title":"Example application: Use isdef for Traits","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Traits are a common mean to get back something like multiple inheritance to Julia.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's say you want to dispatch on anything which provides a certain interface, which in julia simply means that a set of respective functions are defined for the type.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"struct MyType end\ninterface_func1(::MyType) = :hello\ninterface_func2(::MyType) = \"world\"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Then the standard Trait pattern (sometimes called Holy Traits) goes like follows:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"abstract type AbstractMyTrait end\nstruct SupportsMyTrait <: AbstractMyTrait end\n\ntraits_func(a::A) where A = traits_func(AbstractMyTrait(A), a)\ntraits_func(::SupportsMyTrait, a) = println(interface_func1(a), interface_func2(a))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This defines a generic function which dispatches on our given trait type. Yet the trait needs to be associated with our interface function. This is usually done by mere convention, and we just link the trait-type with our custom type, assuming all functions are readily defined","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"AbstractMyTrait(::Type{MyType}) = SupportsMyTrait()  # use instance","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now our traits function works","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"traits_func(MyType())\n# helloworld","category":"page"},{"location":"manual/#No-boilerplate-with-isdef","page":"Manual","title":"No boilerplate with isdef","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The standard Traits implementation creates a lot of boilerplate. Do you really need to define these extra abstract trait types, trait structs and connection between your custom type and the trait type?","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You already defined that MyType implements my_func. We can reuse that information with isdef. This is how to rewrite the above traits_func (we use Val to dispatch on Bool values):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using IsDef\nsupports_interface(a) = isdef(interface_func1, a) && isdef(interface_func2, a)\ntraits_func_new(a) = traits_func_new(Val{supports_interface(a)}(), a)\ntraits_func_new(::Val{true}, a) = println(interface_func1(a), interface_func2(a))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Which indeed works without defining any extra traits type:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"traits_func_new(MyType())\n# helloworld","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The nested dispatch syntax, as well as the use of Val can be simplified further by using a dedicated Trait systems like WhereTraits.jl.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using WhereTraits\n@traits function traits_func_new2(a) where {supports_interface(a)}\n    println(interface_func1(a), interface_func2(a))\nend\ntraits_func_new2(MyType())\n# helloworld","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"or without the supports_interface helper:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using WhereTraits\n@traits function traits_func_new3(a) where {\n        isdef(interface_func1, a),\n        isdef(interface_func2, a),\n    }\n    println(interface_func1(a), interface_func2(a))\nend\ntraits_func_new3(MyType())\n# helloworld","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that isdef does not rely on convention, but checks whether the interface functions are defined or not.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If isdef does return false despite it should be true, the fallback type inference was not good enough and you need to overload Out for either your interface functions or functions used within these. ⚠️ Never overload isdef, instead always overload Out(::Type{<:Tuple{...}}) ⚠️.","category":"page"},{"location":"manual/#Why-not-using-Julia's-builtin-type-inference-directly?","page":"Manual","title":"Why not using Julia's builtin type-inference directly?","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Julia already has a type inference method, namely Base.promote_op which internally uses Core.Compiler.return_type. So why do we need another type inference layer like IsDef?","category":"page"},{"location":"manual/#The-problem:-Instability","page":"Manual","title":"The problem: Instability","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The issue with Core.Compiler.return_type is that we cannot rely on its output. Sometimes just changing the order of Julia code will change the type inference. Think of it as an implementation detail of Julia itself.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Here the official warning in the Base.promote_op docs:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Due to its fragility, use of promoteop should be avoided. It is preferable to base the container eltype on the type of the actual elements. Only in the absence of any elements (for an empty result container), it may be unavoidable to call promoteop.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"And even using Base.promote_op for empty containers is not a good idea, use Any instead, or Union{}. Relying on an indeterministic implementation detail which may silently change its behaviour on every minor julia version is just bad practice.","category":"page"},{"location":"manual/#Where-IsDef's-stability-comes-from","page":"Manual","title":"Where IsDef's stability comes from","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"That said, Julia's type-inference is very useful in that it is the best approximation we can get without any extra knowledge (remember, the worst type inference approximation is always Any). Hence it would be great to somehow use it in a safe manner.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"IsDef uses Julia's default type inference as a fallback, and adds three safety aspects:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"IsDef uses automatice deterministic code generation where possible in order to entirely circumvent Julia's internal type inference\nIsDef makes the type inference overloadable, so that if some fallback type inference changes between Julia versions, you can add a custom inference rule yourself to fix it.\nValTypes define a clean interface to work with bits values as part of type inference.","category":"page"},{"location":"manual/#Automatic-Code-Generation","page":"Manual","title":"Automatic Code Generation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In case no custom inference rule could be found for Out, some type-inference code will be generated for you automatically.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This means that you only need to define custom inference rules in a very few situations. Here the most typical cases for when automatic code generation won't be enough:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"the default inference is too wide (you see this if Out returns some abstract type like Number, but actually you know that the inference could a concreter type like Integer or Int64)\nthe default inference is too inefficient (this is quite hard to track down, but may be seen by profiling your code).\nyou get a warning which explicitly recommends to define a custom inference rule. ⚠️ Note that isdef will not print warnings, you need to use Out to see warnings ⚠️.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If the automatic code generation fails, Out falls back to IsDef.Core_return_type, which wraps Core.Compiler.return_type. In most cases this leads good inference results, but sometimes infers types inaccurately, in which case IsDef.Core_return_type prints the above mentioned warning and returns a special return type IsDef.UnsureWhetherApplicable instead. ⚠️ While this is easily inspectible when using Out directly, please note that isdef follows a conservative semantics and hence will return false in such cases ⚠️.","category":"page"},{"location":"manual/#isdef(f,-...)","page":"Manual","title":"isdef(f, ...)","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"isdef checks whether a given function is defined for subsequent argument-types. Note that in some cases isdef returns false despite the method being properly implemented for the given types (see the section Automatic Code Generation for details).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> isdef(+, Int, Int)\ntrue\njulia> isdef(-, Float32)\ntrue\njulia> isdef(-, String)\nfalse\njulia> isdef(-, AbstractString)\nfalse\njulia> isdef(-, Any)\nfalse","category":"page"},{"location":"manual/#Out(f,-...)","page":"Manual","title":"Out(f, ...)","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Out follows the same syntax as isdef however instead of returning a Bool, it returns the actual inferred returntype.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"<!– the output of Type aliases like Vector changed between julia versions, hence we don't use jldoctest –>","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> Out(Base.map, typeof(string), Vector{Int})\nVector{String} (alias for Array{String, 1})","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If the function is not defined, it returns a special exported type NotApplicable. This ensures that Out can safely be used for dispatch.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> Out(-, AbstractString)\nNotApplicable","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can also do higher-order inference, e.g. when working with Base.map. Usually you would need a concrete function for its first argument, like","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"<!– the output of Type aliases like Vector changed between julia versions, hence we don't use jldoctest –>","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> Out(Base.map, typeof(isodd), Vector{Int})\nVector{Bool} (alias for Array{Bool, 1})","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Thanks to the package FunctionWrappers you can define Function types also directly, without having a concrete function:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"<!– the output of Type aliases like Vector changed between julia versions, hence we don't use jldoctest –>","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> import FunctionWrappers: FunctionWrapper\n\njulia> Out(Base.map, FunctionWrapper{Bool, Tuple{Any}}, Vector{Int})\nVector{Bool} (alias for Array{Bool, 1})","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The special type Any will usually result in a NotApplicable.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> Out(-, Any)\nNotApplicable","category":"page"},{"location":"manual/#What-if-I-only-have-a-function-type?-Use-apply.","page":"Manual","title":"What if I only have a function-type? Use apply.","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"IsDef also exports a little helper function apply which you can use to infer with function-types instead of function-instances.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> isdef(apply, typeof(sin), Int)\ntrue\njulia> Out(apply, typeof(sin), Int)\nFloat64","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"DocTestSetup = nothing","category":"page"},{"location":"manual/#ValTypes","page":"Manual","title":"ValTypes","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Julia's type inference does take into account types as well as some values. For instance, if you use a boolean variable somewhere which is known to be true, and have an if-else using it, julia may well be able to statically optimize your code accordingly.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In order to simplify maintainable type inference which takes into account such value-level type inference, IsDef exports a special Type ValType with separate constructor ValTypeof. (Helper functions along this type can be found in the exported submodule ValTypes).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> ValTypeof(true)\nValType{Bool, true}","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"isdef, Out (and also IsDef.Core_return_type) all work on these ValTypes as well and may return ValTypes.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> isdef(-, ValTypeof(3))\ntrue\n\njulia> Out(!, ValTypeof(true))\nValType{Bool, false}\n\njulia> IsDef.Core_return_type(Tuple{typeof(&), ValTypeof(true), ValTypeof(false)})  # wraps Core.Compiler.return_type\nValType{Bool, false}\n\njulia> Out(Tuple{typeof(|), ValTypeof(true), ValTypeof(false)})\nValType{Bool, true}","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This way you can dispatch on concrete values when specifying custom inference rules.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If you want to dispatch on standard Int or Symbol or another bits-type, you can still do so: Just combine the plain type with its ValType analog in a Union type like Union{Int, ValType{Int}}.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> ValTypeof(1)    <: Union{Int, ValType{Int}}\ntrue\njulia> ValTypeof(:two) <: Union{Int, ValType{Int}}\nfalse\njulia> ValTypeof(1)    <: (Union{T, ValType{T}} where T <: Union{Symbol, Int})\ntrue\njulia> ValTypeof(:two) <: (Union{T, ValType{T}} where T <: Union{Symbol, Int})\ntrue","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Limitations: Currently, Julia's typeinference does not work well if the value is not known at compile time. Practically, this means you should use ValTypeof only for constants or for values which you extracted from another ValType. (See this discourse thread for more details.)","category":"page"},{"location":"#IsDef.jl","page":"Home","title":"IsDef.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For installation or usage, open julia repl and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using IsDef","category":"page"},{"location":"","page":"Home","title":"Home","text":"which gives you access to following functions","category":"page"},{"location":"","page":"Home","title":"Home","text":"isdef(f, arg1, arg2)::Bool / isdef(f, Arg1Type, Arg2Type)::Bool checks whether a function is defined for the given types.\nIf at least one of the arguments is not a type,   all arguments are automatically converted to types for you.\nOut(f, arg1, arg2)::ReturnType / Out(f, Arg1Type, Arg2Type)::ReturnType returns the returntype of the given functioncall.\nNote, that Out may return an abstract type that is wider than necessary, like e.g. Any.   If a functioncall is not defined, or predictably throws an error, IsDef.NotApplicable is returned.   Out is internally used by isdef.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Internally of Out(f, Arg1Type, Arg2Type) a one-argument-version of Out is used which expects a single Tuple type, specifying the entire call signature. This is the heart of the IsDef package. For the example it would be","category":"page"},{"location":"","page":"Home","title":"Home","text":"Out(Tuple{typeof(f), Arg1Type, Arg2Type})","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to specify inference of your method (output of Out), or whether it is defined (output of isdef), you need to overload this very one-argument method of Out. For the example it could be","category":"page"},{"location":"","page":"Home","title":"Home","text":"Out(::Type{<:Tuple{typeof(f), Arg1Type, Arg2Type, Vararg}}) = ReturnType","category":"page"},{"location":"","page":"Home","title":"Home","text":"Enjoy maintainable type inference.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Library Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"}]
}
