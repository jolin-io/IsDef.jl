<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · IsDef.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://jolin-io.github.io/IsDef.jl/manual/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">IsDef.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Example-application:-Use-isdef-for-Traits"><span>Example application: Use <code>isdef</code> for Traits</span></a></li><li><a class="tocitem" href="#Why-not-using-Julia&#39;s-builtin-type-inference-directly?"><span>Why not using Julia&#39;s builtin type-inference directly?</span></a></li><li><a class="tocitem" href="#Automatic-Code-Generation"><span>Automatic Code Generation</span></a></li><li><a class="tocitem" href="#isdef(f,-...)"><span><code>isdef(f, ...)</code></span></a></li><li><a class="tocitem" href="#Out(f,-...)"><span><code>Out(f, ...)</code></span></a></li><li><a class="tocitem" href="#What-if-I-only-have-a-function-type?-Use-apply."><span>What if I only have a function-type? Use <code>apply</code>.</span></a></li><li><a class="tocitem" href="#ValTypes"><span>ValTypes</span></a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jolin-io/IsDef.jl/blob/main/docs/src/manual.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>This package provides primitives for dispatching on whether certain methods are implemented or not.</p><p>For installation or usage, open julia repl and run</p><pre><code class="language-julia hljs">using IsDef</code></pre><p>which gives you access to following functions</p><ul><li><p><code>isdef(f, arg1, arg2)::Bool</code> / <code>isdef(f, Arg1Type, Arg2Type)::Bool</code> checks whether a function is defined for the given types.</p><p>If at least one of the arguments is not a type,   all arguments are automatically converted to types for you.</p></li><li><p><code>Out(f, arg1, arg2)::ReturnType</code> / <code>Out(f, Arg1Type, Arg2Type)::ReturnType</code> returns the returntype of the given functioncall.</p><p>Note, that <code>Out</code> may return an abstract type that is wider than necessary, like e.g. <code>Any</code>.   If a functioncall is not defined, or predictably throws an error, <code>IsDef.NotApplicable</code> is returned.   <code>Out</code> is internally used by <code>isdef</code>.</p></li></ul><p>Internally of <code>Out(f, Arg1Type, Arg2Type)</code> a one-argument-version of <code>Out</code> is used which expects a single Tuple type, specifying the entire call signature. This is the heart of the <code>IsDef</code> package. For the example it would be</p><ul><li><code>Out(Tuple{typeof(f), Arg1Type, Arg2Type})</code></li></ul><p>If you want to specify inference of your method (output of <code>Out</code>), or whether it is defined (output of <code>isdef</code>), you need to overload this very one-argument method of <code>Out</code>. For the example it could be</p><ul><li><code>Out(::Type{&lt;:Tuple{typeof(f), Arg1Type, Arg2Type, Vararg}}) = ReturnType</code></li></ul><p>Enjoy maintainable type inference.</p><h2 id="Example-application:-Use-isdef-for-Traits"><a class="docs-heading-anchor" href="#Example-application:-Use-isdef-for-Traits">Example application: Use <code>isdef</code> for Traits</a><a id="Example-application:-Use-isdef-for-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Example-application:-Use-isdef-for-Traits" title="Permalink"></a></h2><p>Traits are a common mean to get back something like multiple inheritance to Julia.</p><p>Let&#39;s say you want to dispatch on anything which provides a certain interface, which in julia simply means that a set of respective functions are defined for the type.</p><pre><code class="language-julia hljs">struct MyType end
interface_func1(::MyType) = :hello
interface_func2(::MyType) = &quot;world&quot;</code></pre><p>Then the standard Trait pattern (sometimes called Holy Traits) goes like follows:</p><pre><code class="language-julia hljs">abstract type AbstractMyTrait end
struct SupportsMyTrait &lt;: AbstractMyTrait end

traits_func(a::A) where A = traits_func(AbstractMyTrait(A), a)
traits_func(::SupportsMyTrait, a) = println(interface_func1(a), interface_func2(a))</code></pre><p>This defines a generic function which dispatches on our given trait type. Yet the trait needs to be associated with our interface function. This is usually done by mere convention, and we just link the trait-type with our custom type, assuming all functions are readily defined</p><pre><code class="language-julia hljs">AbstractMyTrait(::Type{MyType}) = SupportsMyTrait()  # use instance</code></pre><p>Now our traits function works</p><pre><code class="language-julia hljs">traits_func(MyType())
# helloworld</code></pre><h3 id="No-boilerplate-with-isdef"><a class="docs-heading-anchor" href="#No-boilerplate-with-isdef">No boilerplate with <code>isdef</code></a><a id="No-boilerplate-with-isdef-1"></a><a class="docs-heading-anchor-permalink" href="#No-boilerplate-with-isdef" title="Permalink"></a></h3><p>The standard Traits implementation creates a lot of boilerplate. Do you really need to define these extra abstract trait types, trait structs and connection between your custom type and the trait type?</p><p>You already defined that <code>MyType</code> implements <code>my_func</code>. We can reuse that information with <code>isdef</code>. This is how to rewrite the above <code>traits_func</code> (we use <code>Val</code> to dispatch on <code>Bool</code> values):</p><pre><code class="language-julia hljs">using IsDef
supports_interface(a) = isdef(interface_func1, a) &amp;&amp; isdef(interface_func2, a)
traits_func_new(a) = traits_func_new(Val{supports_interface(a)}(), a)
traits_func_new(::Val{true}, a) = println(interface_func1(a), interface_func2(a))</code></pre><p>Which indeed works without defining any extra traits type:</p><pre><code class="language-julia hljs">traits_func_new(MyType())
# helloworld</code></pre><p>The nested dispatch syntax, as well as the use of <code>Val</code> can be simplified further by using a dedicated Trait systems like <a href="https://github.com/jolin-io/WhereTraits.jl">WhereTraits.jl</a>.</p><pre><code class="language-julia hljs">using WhereTraits
@traits function traits_func_new2(a) where {supports_interface(a)}
    println(interface_func1(a), interface_func2(a))
end
traits_func_new2(MyType())
# helloworld</code></pre><p>or without the <code>supports_interface</code> helper:</p><pre><code class="language-julia hljs">using WhereTraits
@traits function traits_func_new3(a) where {
        isdef(interface_func1, a),
        isdef(interface_func2, a),
    }
    println(interface_func1(a), interface_func2(a))
end
traits_func_new3(MyType())
# helloworld</code></pre><p>Note that <code>isdef</code> does not rely on convention, but checks whether the interface functions are defined or not.</p><p>If <code>isdef</code> does return <code>false</code> despite it should be true, the fallback type inference was not good enough and you need to overload <code>Out</code> for either your interface functions or functions used within these. ⚠️ Never overload <code>isdef</code>, instead always overload <code>Out(::Type{&lt;:Tuple{...}})</code> ⚠️.</p><h2 id="Why-not-using-Julia&#39;s-builtin-type-inference-directly?"><a class="docs-heading-anchor" href="#Why-not-using-Julia&#39;s-builtin-type-inference-directly?">Why not using Julia&#39;s builtin type-inference directly?</a><a id="Why-not-using-Julia&#39;s-builtin-type-inference-directly?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-not-using-Julia&#39;s-builtin-type-inference-directly?" title="Permalink"></a></h2><p>Julia already has a type inference method, namely <code>Base.promote_op</code> which internally uses <code>Core.Compiler.return_type</code>. So why do we need another type inference layer like <code>IsDef</code>?</p><h3 id="The-problem:-Instability"><a class="docs-heading-anchor" href="#The-problem:-Instability">The problem: Instability</a><a id="The-problem:-Instability-1"></a><a class="docs-heading-anchor-permalink" href="#The-problem:-Instability" title="Permalink"></a></h3><p>The issue with <code>Core.Compiler.return_type</code> is that we cannot rely on its output. Sometimes just changing the order of Julia code will change the type inference. Think of it as an implementation detail of Julia itself.</p><p>Here the official warning in the <code>Base.promote_op</code> docs:</p><blockquote><p>Due to its fragility, use of promote<em>op should be avoided. It is preferable to base the container eltype on the type of the actual elements. Only in the absence of any elements (for an empty result container), it may be unavoidable to call promote</em>op.</p></blockquote><p>And even using <code>Base.promote_op</code> for empty containers is not a good idea, use <code>Any</code> instead, or <code>Union{}</code>. Relying on an indeterministic implementation detail which may silently change its behaviour on every minor julia version is just bad practice.</p><h3 id="Where-IsDef&#39;s-stability-comes-from"><a class="docs-heading-anchor" href="#Where-IsDef&#39;s-stability-comes-from">Where IsDef&#39;s stability comes from</a><a id="Where-IsDef&#39;s-stability-comes-from-1"></a><a class="docs-heading-anchor-permalink" href="#Where-IsDef&#39;s-stability-comes-from" title="Permalink"></a></h3><p>That said, Julia&#39;s type-inference is very useful in that it is the best approximation we can get without any extra knowledge (remember, the worst type inference approximation is always <code>Any</code>). Hence it would be great to somehow use it in a safe manner.</p><p><code>IsDef</code> uses Julia&#39;s default type inference as a fallback, and adds three safety aspects:</p><ul><li><code>IsDef</code> uses automatice deterministic code generation where possible in order to entirely circumvent Julia&#39;s internal type inference</li><li><code>IsDef</code> makes the type inference overloadable, so that if some fallback type inference changes between Julia versions, you can add a custom inference rule yourself to fix it.</li><li><a href="#valtypes">ValTypes</a> define a clean interface to work with bits values as part of type inference.</li></ul><h2 id="Automatic-Code-Generation"><a class="docs-heading-anchor" href="#Automatic-Code-Generation">Automatic Code Generation</a><a id="Automatic-Code-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Code-Generation" title="Permalink"></a></h2><p>In case no custom inference rule could be found for <code>Out</code>, some type-inference code will be generated for you automatically.</p><p>This means that you only need to define custom inference rules in a very few situations. Here the most typical cases for when automatic code generation won&#39;t be enough:</p><ul><li>the default inference is too wide (you see this if <code>Out</code> returns some abstract type like <code>Number</code>, but actually you know that the inference could a concreter type like <code>Integer</code> or <code>Int64</code>)</li><li>the default inference is too inefficient (this is quite hard to track down, but may be seen by profiling your code).</li><li>you get a warning which explicitly recommends to define a custom inference rule. ⚠️ Note that <code>isdef</code> will not print warnings, you need to use <code>Out</code> to see warnings ⚠️.</li></ul><p>If the automatic code generation fails, <code>Out</code> falls back to <code>IsDef.Core_return_type</code>, which wraps <code>Core.Compiler.return_type</code>. In most cases this leads good inference results, but sometimes infers types inaccurately, in which case <code>IsDef.Core_return_type</code> prints the above mentioned warning and returns a special return type <code>IsDef.UnsureWhetherApplicable</code> instead. ⚠️ While this is easily inspectible when using <code>Out</code> directly, please note that <code>isdef</code> follows a conservative semantics and hence will return <code>false</code> in such cases ⚠️.</p><h2 id="isdef(f,-...)"><a class="docs-heading-anchor" href="#isdef(f,-...)"><code>isdef(f, ...)</code></a><a id="isdef(f,-...)-1"></a><a class="docs-heading-anchor-permalink" href="#isdef(f,-...)" title="Permalink"></a></h2><p><code>isdef</code> checks whether a given function is defined for subsequent argument-types. Note that in some cases <code>isdef</code> returns <code>false</code> despite the method being properly implemented for the given types (see the section <a href="#automatic-code-generation">Automatic Code Generation</a> for details).</p><pre><code class="language-julia-repl hljs">julia&gt; isdef(+, Int, Int)
true
julia&gt; isdef(-, Float32)
true
julia&gt; isdef(-, String)
false
julia&gt; isdef(-, AbstractString)
false
julia&gt; isdef(-, Any)
false</code></pre><h2 id="Out(f,-...)"><a class="docs-heading-anchor" href="#Out(f,-...)"><code>Out(f, ...)</code></a><a id="Out(f,-...)-1"></a><a class="docs-heading-anchor-permalink" href="#Out(f,-...)" title="Permalink"></a></h2><p><code>Out</code> follows the same syntax as <code>isdef</code> however instead of returning a Bool, it returns the actual inferred returntype.</p><p>&lt;!– the output of Type aliases like Vector changed between julia versions, hence we don&#39;t use jldoctest –&gt;</p><pre><code class="language-julia hljs">julia&gt; Out(Base.map, typeof(string), Vector{Int})
Vector{String} (alias for Array{String, 1})</code></pre><p>If the function is not defined, it returns a special exported type <code>NotApplicable</code>. This ensures that <code>Out</code> can safely be used for dispatch.</p><pre><code class="language-julia-repl hljs">julia&gt; Out(-, AbstractString)
NotApplicable</code></pre><p>You can also do higher-order inference, e.g. when working with <code>Base.map</code>. Usually you would need a concrete function for its first argument, like</p><p>&lt;!– the output of Type aliases like Vector changed between julia versions, hence we don&#39;t use jldoctest –&gt;</p><pre><code class="language-julia hljs">julia&gt; Out(Base.map, typeof(isodd), Vector{Int})
Vector{Bool} (alias for Array{Bool, 1})</code></pre><p>Thanks to the package <code>FunctionWrappers</code> you can define Function types also directly, without having a concrete function:</p><p>&lt;!– the output of Type aliases like Vector changed between julia versions, hence we don&#39;t use jldoctest –&gt;</p><pre><code class="language-julia hljs">julia&gt; import FunctionWrappers: FunctionWrapper

julia&gt; Out(Base.map, FunctionWrapper{Bool, Tuple{Any}}, Vector{Int})
Vector{Bool} (alias for Array{Bool, 1})</code></pre><hr/><p>The special type <code>Any</code> will usually result in a <code>NotApplicable</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; Out(-, Any)
NotApplicable</code></pre><h2 id="What-if-I-only-have-a-function-type?-Use-apply."><a class="docs-heading-anchor" href="#What-if-I-only-have-a-function-type?-Use-apply.">What if I only have a function-type? Use <code>apply</code>.</a><a id="What-if-I-only-have-a-function-type?-Use-apply.-1"></a><a class="docs-heading-anchor-permalink" href="#What-if-I-only-have-a-function-type?-Use-apply." title="Permalink"></a></h2><p><code>IsDef</code> also exports a little helper function <code>apply</code> which you can use to infer with function-types instead of function-instances.</p><pre><code class="language-julia-repl hljs">julia&gt; isdef(apply, typeof(sin), Int)
true
julia&gt; Out(apply, typeof(sin), Int)
Float64</code></pre><h2 id="ValTypes"><a class="docs-heading-anchor" href="#ValTypes">ValTypes</a><a id="ValTypes-1"></a><a class="docs-heading-anchor-permalink" href="#ValTypes" title="Permalink"></a></h2><p>Julia&#39;s type inference does take into account types as well as some values. For instance, if you use a boolean variable somewhere which is known to be <code>true</code>, and have an if-else using it, julia may well be able to statically optimize your code accordingly.</p><p>In order to simplify maintainable type inference which takes into account such value-level type inference, <code>IsDef</code> exports a special Type <code>ValType</code> with separate constructor <code>ValTypeof</code>. (Helper functions along this type can be found in the exported submodule <code>ValTypes</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; ValTypeof(true)
ValType{Bool, true}</code></pre><p><code>isdef</code>, <code>Out</code> (and also <code>IsDef.Core_return_type</code>) all work on these ValTypes as well and may return ValTypes.</p><pre><code class="language-julia-repl hljs">julia&gt; isdef(-, ValTypeof(3))
true

julia&gt; Out(!, ValTypeof(true))
ValType{Bool, false}

julia&gt; IsDef.Core_return_type(Tuple{typeof(&amp;), ValTypeof(true), ValTypeof(false)})  # wraps Core.Compiler.return_type
ValType{Bool, false}

julia&gt; Out(Tuple{typeof(|), ValTypeof(true), ValTypeof(false)})
ValType{Bool, true}</code></pre><p>This way you can dispatch on concrete values when specifying custom inference rules.</p><p>If you want to dispatch on standard <code>Int</code> or <code>Symbol</code> or another bits-type, you can still do so: Just combine the plain type with its ValType analog in a Union type like <code>Union{Int, ValType{Int}}</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; ValTypeof(1)    &lt;: Union{Int, ValType{Int}}
true
julia&gt; ValTypeof(:two) &lt;: Union{Int, ValType{Int}}
false
julia&gt; ValTypeof(1)    &lt;: (Union{T, ValType{T}} where T &lt;: Union{Symbol, Int})
true
julia&gt; ValTypeof(:two) &lt;: (Union{T, ValType{T}} where T &lt;: Union{Symbol, Int})
true</code></pre><p>Limitations: Currently, Julia&#39;s typeinference does not work well if the value is not known at compile time. Practically, this means you should use <code>ValTypeof</code> only for constants or for values which you extracted from another <code>ValType</code>. (See <a href="https://discourse.julialang.org/t/surprising-type-widening-when-constructing-tuple/92840">this discourse thread</a> for more details.)</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../library/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 14 January 2023 14:07">Saturday 14 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
