<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · IsDef.jl</title><link rel="canonical" href="https://schlichtanders.github.io/IsDef.jl/manual/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">IsDef.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/schlichtanders/IsDef.jl/blob/master/docs/src/manual.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>This package provides primitives for dispatching on whether certain methods are implemented or not. It exports two functions for general usage</p><ul><li><code>isdef(f, Arg1Type, Arg2Type, ...)::Bool</code> and</li><li><code>Out(f, Arg1Type, Arg2Type)::ReturnType</code></li></ul><p>which build upon an internal function <code>IsDef.return_type(Tuple{typeof(f), Arg1Type, Arg2Type, ...})::ReturnType</code>.</p><h2 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h2><p>Use <code>isdef</code> / <code>Out</code> for your dispatch cases, but be aware that sometimes Julia&#39;s inference is only approximate. The package does a lot to improve over the default inference, but there are still limitations, just that you know:</p><ol><li>sometimes the inferred type may be more general then the real concrete type</li><li>sometimes a type is inferred, while in real an error is thrown (this especially holds true if one of your ArgTypes is <code>Any</code>)</li></ol><p>Accordingly, here some notes about safety:</p><ul><li><code>isdef</code> is usually safe to use, as you don&#39;t care about the specific return type. In the rare case that some function was actually not defined despite saying so, you will get a loud MethodError at runtime, precisely stating which method was not defined. Then you can fix the missing type-inference yourself by overloading <code>IsDef.return_type</code> (see below) and you are safe to go.</li><li><code>Out</code> is definitely trickier, as here the precise type may matter. The recommendation is to use it only if you are fine with (1.), i.e. it is okay for you if you get a more general type in some cases.</li></ul><p>If you encounter limitations or too broad type-inference, you can always overload the underlying <code>return_type</code></p><pre><code class="language-julia">IsDef.return_type(::Type{Tuple{typeof(myfunction), Arg1Type, Arg2Type}}) = ReturnType</code></pre><p>Specifically, if you want to indicate that a given function is not defined for certain argument types, you return <code>Union{}</code></p><pre><code class="language-julia"># Union{} denotes being undefined
IsDef.return_type(::Type{Tuple{typeof(myfunction), Arg1Type, Arg2Type}}) = Union{}  </code></pre><h2 id="Loading-IsDef"><a class="docs-heading-anchor" href="#Loading-IsDef">Loading IsDef</a><a id="Loading-IsDef-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-IsDef" title="Permalink"></a></h2><p>Run</p><pre><code class="language-julia">using IsDef</code></pre><p>which makes <code>isdef</code> and <code>Out</code> available.</p><h2 id="isdef(f,-...)"><a class="docs-heading-anchor" href="#isdef(f,-...)"><code>isdef(f, ...)</code></a><a id="isdef(f,-...)-1"></a><a class="docs-heading-anchor-permalink" href="#isdef(f,-...)" title="Permalink"></a></h2><p><code>isdef</code> checks whether a given function is defined for subsequent argument-types</p><pre><code class="language-julia-repl">julia&gt; isdef(+, Int, Int)
true
julia&gt; isdef(-, AbstractFloat)
true
julia&gt; isdef(-, String)
false
julia&gt; isdef(-, AbstractString)
false</code></pre><p>Caution has to be taken for the type <span>$Any$</span>. It is the only special case. It is interpreted as if type-inference was in-accurate, and the concrete values are actually something more specific than Any. This is why, <span>$Any$</span> always results in <span>$true$</span>.</p><pre><code class="language-julia-repl">julia&gt; isdef(-, Any)
true</code></pre><h2 id="Out(f,-...)"><a class="docs-heading-anchor" href="#Out(f,-...)"><code>Out(f, ...)</code></a><a id="Out(f,-...)-1"></a><a class="docs-heading-anchor-permalink" href="#Out(f,-...)" title="Permalink"></a></h2><p><code>Out</code> follows the same syntax as <code>isdef</code> however instead of returning a Bool, it returns the actual inferred returntype.</p><pre><code class="language-julia-repl">julia&gt; Out(Base.map, typeof(string), Vector{Int})
Vector{String}</code></pre><p>If the function is not defined, it returns a special exported type <code>NotApplicable</code> (and not the standard convention <code>Union{}</code>). This ensures that <code>Out</code> can be used for dispatch.</p><pre><code class="language-julia-repl">julia&gt; Out(-, AbstractString)
IsDef.NotApplicable</code></pre><p>You can also do higher-order inference, e.g. when working with <code>Base.map</code>. Usually you would need a concrete function for its first argument, like</p><pre><code class="language-julia-repl">julia&gt; Out(Base.map, typeof(isodd), Vector{Int})
Array{Bool, 1}</code></pre><p>But thanks to the package <span>$FunctionWrappers$</span> you can define Function types also directly, without having a concrete function:</p><pre><code class="language-julia-repl">julia&gt; import FunctionWrappers: FunctionWrapper
julia&gt; Out(Base.map, FunctionWrapper{Bool, Tuple{Any}}, Vector{Int})
Vector{Bool}</code></pre><hr/><p>Be cautious about <code>Any</code>, as it will usually work for every function, resulting again in an <span>$Any$</span>.</p><pre><code class="language-julia">Out(-, Any)  # Any</code></pre><h2 id="What-if-I-only-have-a-function-type?-Use-apply"><a class="docs-heading-anchor" href="#What-if-I-only-have-a-function-type?-Use-apply">What if I only have a function-type? Use <code>apply</code></a><a id="What-if-I-only-have-a-function-type?-Use-apply-1"></a><a class="docs-heading-anchor-permalink" href="#What-if-I-only-have-a-function-type?-Use-apply" title="Permalink"></a></h2><p><code>IsDef</code> also exports a little helper function <code>apply</code> which you can use to infer with function-types instead of function-instances.</p><pre><code class="language-julia-repl">julia&gt; isdef(apply, typeof(sin), Int)
true
julia&gt; Out(apply, typeof(sin), Int)
Float64</code></pre><p>The implementation in the background actually ensures that this takes into account custom fixes of <span>$IsDef.return_type$</span>, too.</p><pre><code class="language-julia">struct MyNewType end
IsDef.return_type(::Type{Tuple{typeof(identity), MyNewType}}) = Union{}
isdef(apply, typeof(identity), MyNewType)

# Output

false</code></pre><div class="admonition is-warning"><header class="admonition-header">This only works with the `IsDef.apply`</header><div class="admonition-body"><p>A custom apply won&#39;t work</p><pre><code class="language-julia">isdef((f, args...) -&gt; f(args...), typeof(identity), MyNewType)

# output

true</code></pre></div></div></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 12 July 2020 18:37">Sunday 12 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
